-- XTreeF l n a = < leaf : l | node : { node : n, subtrees : a } >
-- TODO: implement Monad/join

let XTree = ./Type

let XTreeF = ../XTreeF/Type

let XTree/recursive = ./recursive

let List/concatMap = ../List/concatMap

let List/map = ../List/map

let outType =
      λ(l : Type) → λ(n : Type) → List { head : List n, tail : Optional l }

let reciteType = λ(l : Type) → λ(n : Type) → XTree l n → outType l n

in    (   λ(l : Type)
        → λ(n : Type)
        → λ(t : XTree l n)
        → let mapOType = { head : List n, tail : Optional l }
          
          let mapIType =
                < leaf : l | node : { node : n, subtrees : List mapOType } >
          
          let f =
                  λ(i : mapIType)
                → merge
                  { leaf =
                      λ(lx : l) → [ { head = [] : List n, tail = Some lx } ]
                  , node =
                        λ(nx : { node : n, subtrees : List mapOType })
                      → let f =
                                λ(nxx : mapOType)
                              → { head =
                                    nxx.head # [ nx.node ]
                                , tail =
                                    nxx.tail
                                }
                        
                        in  List/map mapOType mapOType f nx.subtrees
                  }
                  i
          
          let reciteAlg =
                  λ(x : XTreeF l n (outType l n))
                → List/concatMap mapIType mapOType f x
          
          in  (XTree/recursive l n).cata (outType l n) reciteAlg t
      )
    : ∀(l : Type) → ∀(n : Type) → reciteType l n
